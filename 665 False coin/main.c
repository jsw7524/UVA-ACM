
#include <iostream.h>
#include <conio.h>
#include <windows.h>

main()
{
    char map[20][20];  //棋盤的二維陣列記憶體
    char ch1,ch2,c1,c2,c3,c4,c5,c6,c,letter;  //輸入與圖案用字元變數
    int  i,j,q,r,t,x,y,z,row,col; //迴圈與陣列用變數
    int  a,b,e,n1,n2,count;   //a,b:選棋變數 n1,n2:玩家總棋數  count:總下棋數

    c1=1,c2=3,c3=3,c4=4,c5=5,c6=6;  //設定編號1~6的棋子圖案(ASCll碼)
    printf("☆請從下方選擇一種喜歡的棋子:\n");
    printf("*************************\n");
    printf("*   1:%c    2:%c    3:%c   *\n",c1,c2,c3);
    printf("*   4:%c    5:%c    6:%c   *\n",c4,c5,c6);
    printf("*************************\n");
    cin>>a;  //玩家選的棋子編號代入變數a中
    printf("☆請問您要先下或是後下? (1)先下(2)後下\n");
    cin>>e;
    if(e==1)
    {
        count=0;
    }
    else
    {
        count=1;
    }
    system("cls");  //清除畫面

    srand(time(NULL));   //以亂數將電腦選一種不與玩家重覆的棋子
    for(i=0; i<1;)
    {
        b=rand()/5445+1;
        if(b!=a)
        {
            i++;
        }
    }

    ch1=a,ch2=b,n1=0,n2=0; //將玩家選的棋編號代入變數ch1中,並設記錄棋數的變數n1,n2為零
    system("cls");
    cout<<"   ";
    for(i=1; i<10; i++)
    {
        cout<<i<<" ";
    }
    for(i=10; i<21; i++)
    {
        cout<<i;
    }
    cout<<endl;

    for(x=1; x<21; x++)
    {
        printf("%2d ",x);
        for(y=1; y<21; y++)
        {
            map[x][y]='.';
            cout<<map[x][y]<<" ";
        }
        cout<<endl;
    }
    printf("******************************************\n");
    printf("*       %c玩家A:%3d     %c電腦:%3d         *\n",ch1,n1,ch2,n2);
    printf("******************************************\n");

    for(q=1; q>0; count++)
    {
        if(count%2==0)
        {
            for(j=0; j<1;)
            {
                for(i=0; i<1;)
                {
                    printf("%c玩家:\n請輸入棋子的X座標(1~20):",ch1);
                    cin>>row;
                    if((row<1)||(row>20))
                    {
                        printf("您輸入的X坐標已超出棋盤,請重新輸入!\n");
                    }
                    else
                    {
                        i++;
                    }
                }
                for(i=0; i<1;)
                {
                    printf("請輸入棋子的y座標(1~20):");
                    cin>>col;
                    if((col<1)||(col>20))
                    {
                        printf("您輸入的y坐標已超出棋盤,請重新輸入!\n");
                    }
                    else
                    {
                        i++;
                    }
                }
                if(map[col][row]!='.')
                {
                    printf("此格已有棋子,請重新輸入!\n");
                }
                else
                {
                    j++;
                }
            }
            map[col][row]=ch1;
            n1++;
        }
        else
        {
            t=0;
            Sleep(1000);

            for(x=1; x<21; x++) // <電腦優先順序1> 當玩家有活四時,電腦去阻擋一邊(其實已輸了!)(防守)
            {
                for(y=1; y<21; y++)
                {
                    //如玩家已有四子的橫連線,以亂數決定擋左方或是右方!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch1)
                            &&(map[x-1][y]=='.')&&(map[x+4][y]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y]=ch2;
                        }
                        else
                        {
                            map[x+4][y]=ch2;
                        }
                        t=1;
                    }
                    //如玩家已有四子的直連線,以亂數決定擋上方或是下方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch1)
                            &&(map[x][y-1]=='.')&&(map[x][y+4]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x][y-1]=ch2;
                        }
                        else
                        {
                            map[x][y+4]=ch2;
                        }
                        t=1;
                    }
                    //如玩家已有四子的左斜連線,以亂數決定擋左上方或是右下方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch1)
                            &&(map[x-1][y-1]=='.')&&(map[x+4][y+4]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y-1]=ch2;
                        }
                        else
                        {
                            map[x+4][y+4]=ch2;
                        }
                        t=1;
                    }
                    //如玩家已有四子的右斜連線,以亂數決定擋左下方或是右上方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch1)
                            &&(map[x+1][y-1]=='.')&&(map[x-4][y+4]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x+1][y-1]=ch2;
                        }
                        else
                        {
                            map[x-4][y+4]=ch2;
                        }
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序2> 當玩家有被電腦擋一邊的四子時,去阻擋一邊!(防守)
            {
                for(y=1; y<21; y++)
                {
                    //如玩家已有被擋左方的四子橫連線,則阻擋右邊!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch1)
                            &&(map[x-1][y]==ch2)&&(map[x+4][y]=='.')&&(t==0))
                    {
                        map[x+4][y]=ch2;
                        t=1;
                    }
                    //如玩家已有被擋右方的四子橫連線,則阻擋左邊!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch1)
                            &&(map[x+4][y]==ch2)&&(map[x-1][y]=='.')&&(t==0))
                    {
                        map[x-1][y]=ch2;
                        t=1;
                    }
                    //如玩家已有被擋上方的四子直連線,則阻擋下方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch1)
                            &&(map[x][y-1]==ch2)&&(map[x][y+4]=='.')&&(t==0))
                    {
                        map[x][y+4]=ch2;
                        t=1;
                    }
                    //如玩家已有被擋下方的四子直連線,則阻擋上方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch1)
                            &&(map[x][y+4]==ch2)&&(map[x][y-1]=='.')&&(t==0))
                    {
                        map[x][y-1]=ch2;
                        t=1;
                    }
                    //如玩家已有被擋左上方的四子左斜連線,則阻擋右下方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch1)
                            &&(map[x-1][y-1]==ch2)&&(map[x+4][y+4]=='.')&&(t==0))
                    {
                        map[x+4][y+4]=ch2;
                        t=1;
                    }
                    //如玩家已有被擋右下方的四子左斜連線,則阻擋左上方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch1)
                            &&(map[x+4][y+4]==ch2)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如玩家已有被擋右上方的四子右斜連線,則阻擋左下方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch1)
                            &&(map[x+1][y-1]==ch2)&&(map[x-4][y+4]=='.')&&(t==0))
                    {
                        map[x-4][y+4]=ch2;
                        t=1;
                    }
                    //如玩家已有被擋左下方的四子右斜連線,則阻擋右上方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch1)
                            &&(map[x-4][y+4]==ch2)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序3> 當玩家有靠邊界的四子時,去阻擋!(防守)
            {
                for(y=1; y<21; y++)
                {
                    //如玩家已有靠左邊界的四子橫連線,則阻擋右方!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch1)
                            &&(x==1)&&(map[x+4][y]=='.')&&(t==0))
                    {
                        map[x+4][y]=ch2;
                        t=1;
                    }
                    //如玩家已有靠右邊界的四子橫連線,則阻擋左方!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch1)
                            &&(x==17)&&(map[x-1][y]=='.')&&(t==0))
                    {
                        map[x-1][y]=ch2;
                        t=1;
                    }
                    //如玩家已有靠上邊界的四子橫連線,則阻擋下方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch1)
                            &&(y==1)&&(map[x][y+4]=='.')&&(t==0))
                    {
                        map[x][y+4]=ch2;
                        t=1;
                    }
                    //如玩家已有靠下邊界的四子橫連線,則阻擋上方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch1)
                            &&(y==17)&&(map[x][y-1]=='.')&&(t==0))
                    {
                        map[x][y-1]=ch2;
                        t=1;
                    }
                    //如玩家已有靠上邊界的四子左斜連線,則阻擋右下方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch1)
                            &&(y==1)&&(map[x+4][y+4]=='.')&&(t==0))
                    {
                        map[x+4][y+4]=ch2;
                        t=1;
                    }
                    //如玩家已有靠下邊界的四子左斜連線,則阻擋左上方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch1)
                            &&(y==17)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如玩家已有靠左邊界的四子左斜連線,則阻擋右下方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch1)
                            &&(x==1)&&(map[x+4][y+4]=='.')&&(t==0))
                    {
                        map[x+4][y+4]=ch2;
                        t=1;
                    }
                    //如玩家已有靠右邊界的四子左斜連線,則阻擋左上方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch1)
                            &&(x==17)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如玩家已有靠上邊界的四子右斜連線,則阻擋左下方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch1)
                            &&(y==1)&&(map[x-4][y+4]=='.')&&(t==0))
                    {
                        map[x-4][y+4]=ch2;
                        t=1;
                    }
                    //如玩家已有靠下邊界的四子右斜連線,則阻擋右上方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch1)
                            &&(y==17)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                    //如玩家已有靠左邊界的四子右斜連線,則阻擋右上方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch1)
                            &&(x==1)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                    //如玩家已有靠右邊界的四子右斜連線,則阻擋左下方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch1)
                            &&(x==17)&&(map[x-4][y+4]=='.')&&(t==0))
                    {
                        map[x-4][y+4]=ch2;
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序4> 當玩家有活三時,去阻擋一邊!(防守)
            {
                for(y=1; y<21; y++)
                {
                    //如玩家已有三子的橫連線,以亂數決定擋左方或是右方!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==ch1)&&(map[x-1][y]=='.')
                            &&(map[x+3][y]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y]=ch2;
                        }
                        else
                        {
                            map[x+3][y]=ch2;
                        }
                        t=1;
                    }
                    //如玩家已有三子的直連線,以亂數決定擋上方或是下方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==ch1)&&(map[x][y-1]=='.')
                            &&(map[x][y+3]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x][y-1]=ch2;
                        }
                        else
                        {
                            map[x][y+3]=ch2;
                        }
                        t=1;
                    }
                    //如玩家已有三子的左斜連線,以亂數決定擋左上方或是右下方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==ch1)&&(map[x-1][y-1]=='.')
                            &&(map[x+3][y+3]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y-1]=ch2;
                        }
                        else
                        {
                            map[x+3][y+3]=ch2;
                        }
                        t=1;
                    }
                    //如玩家已有三子的右斜連線,以亂數決定擋左下方或是右上方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==ch1)&&(map[x+1][y-1]=='.')
                            &&(map[x-3][y+3]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x+1][y-1]=ch2;
                        }
                        else
                        {
                            map[x-3][y+3]=ch2;
                        }
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序5> 當玩家有斷三時,去阻擋中間!(防守)
            {
                for(y=1; y<21; y++)
                {
                    //如玩家已有橫線的斷三-左@ @@右,擋住空位!
                    if((map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch1)&&(map[x+1][y]=='.')&&(t==0))
                    {
                        map[x+1][y]=ch2;
                        t=1;
                    }
                    //如玩家已有橫線的斷三-左@@ @右,擋住空位!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch1)&&(map[x+2][y]=='.')&&(t==0))
                    {
                        map[x+2][y]=ch2;
                        t=1;
                    }
                    //如玩家已有直線的斷三-上@ @@下,擋住空位!
                    if((map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch1)&&(map[x][y+1]=='.')&&(t==0))
                    {
                        map[x][y+1]=ch2;
                        t=1;
                    }
                    //如玩家已有直線的斷三-上@@ @下,擋住空位!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch1)&&(map[x][y+2]=='.')&&(t==0))
                    {
                        map[x][y+2]=ch2;
                        t=1;
                    }
                    //如玩家已有左斜線的斷三-左上@ @@右下,擋住空位!
                    if((map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch1)&&(map[x+1][y+1]=='.')&&(t==0))
                    {
                        map[x+1][y+1]=ch2;
                        t=1;
                    }
                    //如玩家已有左斜線的斷三-左上@@ @右下,擋住空位!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch1)&&(map[x+2][y+2]=='.')&&(t==0))
                    {
                        map[x+2][y+2]=ch2;
                        t=1;
                    }
                    //如玩家已有右斜線的斷三-右上@ @@左下,擋住空位!
                    if((map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch1)&&(map[x-1][y+1]=='.')&&(t==0))
                    {
                        map[x-1][y+1]=ch2;
                        t=1;
                    }
                    //如玩家已有右斜線的斷三-右上@ @@左下,擋住空位!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch1)&&(map[x-2][y+2]=='.')&&(t==0))
                    {
                        map[x-2][y+2]=ch2;
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序6> 當電腦有活四時,補上一子連成線!(進攻)
            {
                for(y=1; y<21; y++)
                {
                    //如有四子的橫連線,以亂數決定加在左方或是右方!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch2)
                            &&(map[x-1][y]=='.')&&(map[x+4][y]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y]=ch2;
                        }
                        else
                        {
                            map[x+4][y]=ch2;
                        }
                        t=1;
                    }
                    //如有四子的直連線,以亂數決定加在上方或是下方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch2)
                            &&(map[x][y-1]=='.')&&(map[x][y+4]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x][y-1]=ch2;
                        }
                        else
                        {
                            map[x][y+4]=ch2;
                        }
                        t=1;
                    }
                    //如有四子的左斜連線,以亂數決定加在左上方或是右下方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch2)
                            &&(map[x-1][y-1]=='.')&&(map[x+4][y+4]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y-1]=ch2;
                        }
                        else
                        {
                            map[x+4][y+4]=ch2;
                        }
                        t=1;
                    }
                    //如有四子的右斜連線,以亂數決定加在右上方或是左下方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch2)
                            &&(map[x+1][y-1]=='.')&&(map[x-4][y+4]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x+1][y-1]=ch2;
                        }
                        else
                        {
                            map[x-4][y+4]=ch2;
                        }
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序7> 當電腦有被玩家擋一邊的四子時,另一邊補上子成線!(進攻)
            {
                for(y=1; y<21; y++)
                {
                    //如電腦已有被擋左方的四子橫連線,則加在右邊!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch2)
                            &&(map[x-1][y]==ch1)&&(map[x+4][y]=='.')&&(t==0))
                    {
                        map[x+4][y]=ch2;
                        t=1;
                    }
                    //如電腦已有被擋右方的四子橫連線,則阻擋左邊!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch2)
                            &&(map[x+4][y]==ch1)&&(map[x-1][y]=='.')&&(t==0))
                    {
                        map[x-1][y]=ch2;
                        t=1;
                    }
                    //如電腦已有被擋上方的四子直連線,則阻擋下方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch2)
                            &&(map[x][y-1]==ch1)&&(map[x][y+4]=='.')&&(t==0))
                    {
                        map[x][y+4]=ch2;
                        t=1;
                    }
                    //如電腦已有被擋下方的四子直連線,則阻擋上方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch2)
                            &&(map[x][y+4]==ch1)&&(map[x][y-1]=='.')&&(t==0))
                    {
                        map[x][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有被擋左上方的四子左斜連線,則阻擋右下方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch2)
                            &&(map[x-1][y-1]==ch1)&&(map[x+4][y+4]=='.')&&(t==0))
                    {
                        map[x+4][y+4]=ch2;
                        t=1;
                    }
                    //如電腦已有被擋右下方的四子左斜連線,則阻擋左上方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch2)
                            &&(map[x+4][y+4]==ch1)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有被擋右上方的四子右斜連線,則阻擋左下方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch2)
                            &&(map[x+1][y-1]==ch1)&&(map[x-4][y+4]=='.')&&(t==0))
                    {
                        map[x-4][y+4]=ch2;
                        t=1;
                    }
                    //如電腦已有被擋左下方的四子右斜連線,則阻擋右上方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch2)
                            &&(map[x-4][y+4]==ch1)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序8> 當電腦有靠邊界的四子時,補上子成線!(進攻)
            {
                for(y=1; y<21; y++)
                {
                    //如電腦已有靠左邊界的四子橫連線,則在右方補上子成線!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch2)
                            &&(x==1)&&(map[x+4][y]=='.')&&(t==0))
                    {
                        map[x+4][y]=ch2;
                        t=1;
                    }
                    //如電腦已有靠右邊界的四子橫連線,則在左方補上子成線!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch2)
                            &&(x==17)&&(map[x-1][y]=='.')&&(t==0))
                    {
                        map[x-1][y]=ch2;
                        t=1;
                    }
                    //如電腦已有靠上邊界的四子橫連線,則在下方補上子成線!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch2)
                            &&(y==1)&&(map[x][y+4]=='.')&&(t==0))
                    {
                        map[x][y+4]=ch2;
                        t=1;
                    }
                    //如電腦已有靠下邊界的四子橫連線,則在上方補上子成線!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch2)
                            &&(y==17)&&(map[x][y-1]=='.')&&(t==0))
                    {
                        map[x][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠上邊界的四子左斜連線,則在右下方補上子成線!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch2)
                            &&(y==1)&&(map[x+4][y+4]=='.')&&(t==0))
                    {
                        map[x+4][y+4]=ch2;
                        t=1;
                    }
                    //如電腦已有靠下邊界的四子左斜連線,則在左上方補上子成線!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch2)
                            &&(y==17)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠左邊界的四子左斜連線,則在右下方補上子成線! !
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch2)
                            &&(x==1)&&(map[x+4][y+4]=='.')&&(t==0))
                    {
                        map[x+4][y+4]=ch2;
                        t=1;
                    }
                    //如電腦已有靠右邊界的四子左斜連線,則在左上方補上子成線!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch2)
                            &&(x==17)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠上邊界的四子右斜連線,則在左下方補上子成線!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch2)
                            &&(y==1)&&(map[x-4][y+4]=='.')&&(t==0))
                    {
                        map[x-4][y+4]=ch2;
                        t=1;
                    }
                    //如電腦已有靠下邊界的四子右斜連線,則在右上方補上子成線!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch2)
                            &&(y==17)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠左邊界的四子右斜連線,則在右上方補上子成線!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch2)
                            &&(x==1)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠右邊界的四子右斜連線,則在左下方補上子成線!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch2)
                            &&(x==17)&&(map[x-4][y+4]=='.')&&(t==0))
                    {
                        map[x-4][y+4]=ch2;
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序9> 當電腦有活三時,加上子變成活四!(進攻)
            {
                for(y=1; y<21; y++)
                {
                    //如電腦已有三子的橫連線,以亂數決定加在左方或是右方!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==ch2)&&(map[x-1][y]=='.')
                            &&(map[x+3][y]=='.')&&(x>=3)&&(x<=16)&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y]=ch2;
                        }
                        else
                        {
                            map[x+3][y]=ch2;
                        }
                        t=1;
                    }
                    //如電腦已有三子的直連線,以亂數決定加在上方或是下方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==ch2)&&(map[x][y-1]=='.')
                            &&(map[x][y+3]=='.')&&(y>=3)&&(y<=16)&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x][y-1]=ch2;
                        }
                        else
                        {
                            map[x][y+3]=ch2;
                        }
                        t=1;
                    }
                    //如電腦已有三子的左斜連線,以亂數決定加在左上方或是右下方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==ch2)&&(map[x-1][y-1]=='.')
                            &&(map[x+3][y+3]=='.')&&(x>=3)&&(x<=16)&&(y>=3)&&(y<=16)&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y-1]=ch2;
                        }
                        else
                        {
                            map[x+3][y+3]=ch2;
                        }
                        t=1;
                    }
                    //如電腦已有三子的右斜連線,以亂數決定加在右上方或是左下方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==ch2)&&(map[x+1][y-1]=='.')
                            &&(map[x-3][y+3]=='.')&&(x>=3)&&(x<=16)&&(y>=3)&&(y<=16)&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x+1][y-1]=ch2;
                        }
                        else
                        {
                            map[x-3][y+3]=ch2;
                        }
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序10> 當電腦有斷三時,在中間補上子!(進攻)
            {
                for(y=1; y<21; y++)
                {
                    //如電腦已有橫線的斷三-左@ @@右,補子於空位!
                    if((map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch2)&&(map[x+1][y]=='.')&&(t==0))
                    {
                        map[x+1][y]=ch2;
                        t=1;
                    }
                    //如電腦已有橫線的斷三-左@@ @右,補子於空位!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+3][y])&&(map[x][y]==ch2)&&(map[x+2][y]=='.')&&(t==0))
                    {
                        map[x+2][y]=ch2;
                        t=1;
                    }
                    //如電腦已有直線的斷三-上@ @@下,補子於空位!
                    if((map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch2)&&(map[x][y+1]=='.')&&(t==0))
                    {
                        map[x][y+1]=ch2;
                        t=1;
                    }
                    //如電腦已有直線的斷三-上@@ @下,補子於空位!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+3])&&(map[x][y]==ch2)&&(map[x][y+2]=='.')&&(t==0))
                    {
                        map[x][y+2]=ch2;
                        t=1;
                    }
                    //如電腦已有左斜線的斷三-左上@ @@右下,補子於空位!
                    if((map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch2)&&(map[x+1][y+1]=='.')&&(t==0))
                    {
                        map[x+1][y+1]=ch2;
                        t=1;
                    }
                    //如電腦已有左斜線的斷三-左上@@ @右下,補子於空位!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+3][y+3])&&(map[x][y]==ch2)&&(map[x+2][y+2]=='.')&&(t==0))
                    {
                        map[x+2][y+2]=ch2;
                        t=1;
                    }
                    //如電腦已有右斜線的斷三-右上@ @@左下,補子於空位!
                    if((map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch2)&&(map[x-1][y+1]=='.')&&(t==0))
                    {
                        map[x-1][y+1]=ch2;
                        t=1;
                    }
                    //如電腦已有右斜線的斷三-右上@ @@左下,補子於空位!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-3][y+3])&&(map[x][y]==ch2)&&(map[x-2][y+2]=='.')&&(t==0))
                    {
                        map[x-2][y+2]=ch2;
                        t=1;
                    }
                }
            }

            for(x=1; x<20; x++) // <電腦優先順序11> 將被玩家擋一邊的三子連成四子(進攻)
            {
                for(y=1; y<20; y++)
                {
                    //如果有被擋左方橫的三顆子,則右方補上一顆連成四子!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==ch2)&&(map[x-1][y]==ch1)
                            &&(map[x+3][y]=='.')&&(x<=16)&&(t==0))
                    {
                        map[x+3][y]=ch2;
                        t=1;
                    }
                    //如果有被擋右方直的三顆子,則左方補上一顆連成四子!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==ch2)&&(map[x+3][y]==ch1)
                            &&(map[x-1][y]=='.')&&(x>=3)&&(t==0))
                    {
                        map[x-1][y]=ch2;
                        t=1;
                    }
                    //如果有被擋上方橫的三顆子,則下方補上一顆連成四子!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==ch2)&&(map[x][y-1]==ch1)
                            &&(map[x][y+3]=='.')&&(x>=3)&&(t==0))
                    {
                        map[x][y+3]=ch2;
                        t=1;
                    }
                    //如果有被擋下方橫的三顆子,則上方補上一顆連成四子!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==ch2)&&(map[x][y+3]==ch1)
                            &&(map[x][y-1]=='.')&&(x<=16)&&(t==0))
                    {
                        map[x][y-1]=ch2;
                        t=1;
                    }
                    //如果有被擋左上方左斜的三顆子,則右下方補上一顆連成四子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==ch2)&&(map[x-1][y-1]==ch1)
                            &&(map[x+3][y+3]=='.')&&(x<=16)&&(y<=16)&&(t==0))
                    {
                        map[x+3][y+3]=ch2;
                        t=1;
                    }
                    //如果有被擋右下方左斜的三顆子,則左上方補上一顆連成四子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==ch2)&&(map[x+3][y+3]==ch1)
                            &&(map[x-1][y-1]=='.')&&(x>=3)&&(y>=3)&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如果有被擋右上方右斜的三顆子,則左下方補上一顆連成四子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==ch2)&&(map[x+1][y-1]==ch1)
                            &&(map[x-3][y+3]=='.')&&(x>=3)&&(y<=16)&&(t==0))
                    {
                        map[x-3][y+3]=ch2;
                        t=1;
                    }
                    //如果有被擋左下方右斜的三顆子,則右上方補上一顆連成四子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==ch2)&&(map[x-3][y+3]==ch1)
                            &&(map[x+1][y-1]=='.')&&(x<=16)&&(y>=3)&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序12> 當電腦有靠邊界的三子時,補上成四子!(進攻)
            {
                for(y=1; y<21; y++)
                {
                    //如電腦已有靠左邊界的三子橫連線,則在右方補上子!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==ch2)&&(x==1)&&(map[x+3][y]=='.')&&(t==0))
                    {
                        map[x+3][y]=ch2;
                        t=1;
                    }
                    //如電腦已有靠右邊界的三子橫連線,則在左方補上子!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==ch2)&&(x==17)&&(map[x-1][y]=='.')&&(t==0))
                    {
                        map[x-1][y]=ch2;
                        t=1;
                    }
                    //如電腦已有靠上邊界的三子直連線,則在下方補上子!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==ch2)&&(y==1)&&(map[x][y+3]=='.')&&(t==0))
                    {
                        map[x][y+3]=ch2;
                        t=1;
                    }
                    //如電腦已有靠下邊界的三子直連線,則在上方補上子!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==ch2)&&(y==17)&&(map[x][y-1]=='.')&&(t==0))
                    {
                        map[x][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠上邊界的三子左斜連線,則在右下方補上子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==ch2)&&(y==1)&&(map[x+3][y+3]=='.')&&(t==0))
                    {
                        map[x+3][y+3]=ch2;
                        t=1;
                    }
                    //如電腦已有靠下邊界的三子左斜連線,則在左上方補上子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==ch2)&&(y==17)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠左邊界的三子左斜連線,則在右下方補上子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==ch2)&&(x==1)&&(map[x+3][y+3]=='.')&&(t==0))
                    {
                        map[x+3][y+3]=ch2;
                        t=1;
                    }
                    //如電腦已有靠右邊界的三子左斜連線,則在左上方補上子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==ch2)&&(x==17)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠上邊界的三子右斜連線,則在左下方補上子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==ch2)&&(y==1)&&(map[x-3][y+3]=='.')&&(t==0))
                    {
                        map[x-3][y+3]=ch2;
                        t=1;
                    }
                    //如電腦已有靠下邊界的三子右斜連線,則在右上方補上子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==ch2)&&(y==17)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠左邊界的三子右斜連線,則在右上方補上子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==ch2)&&(x==1)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠右邊界的三子右斜連線,則在左下方補上子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==ch2)&&(x==17)&&(map[x-3][y+3]=='.')&&(t==0))
                    {
                        map[x-3][y+3]=ch2;
                        t=1;
                    }

                }
            }

            for(x=1; x<21; x++) // <電腦優先順序13> 當電腦有活二時,加上子變成活三!(進攻)
            {
                for(y=1; y<21; y++)
                {
                    //如電腦已有二子的橫連線,以亂數決定加在左方或是右方!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==ch2)&&(map[x-1][y]=='.')&&(map[x+2][y]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y]=ch2;
                        }
                        else
                        {
                            map[x+2][y]=ch2;
                        }
                        t=1;
                    }
                    //如電腦已有二子的直連線,以亂數決定加在上方或是下方!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==ch2)&&(map[x][y-1]=='.')&&(map[x][y+2]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x][y-1]=ch2;
                        }
                        else
                        {
                            map[x][y+2]=ch2;
                        }
                        t=1;
                    }
                    //如電腦已有二子的左斜連線,以亂數決定加在左上方或是右下方!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==ch2)&&(map[x-1][y-1]=='.')&&(map[x+2][y+2]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x-1][y-1]=ch2;
                        }
                        else
                        {
                            map[x+2][y+2]=ch2;
                        }
                        t=1;
                    }
                    //如電腦已有二子的右斜連線,以亂數決定加在右上方或是左下方!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==ch2)&&(map[x+1][y-1]=='.')&&(map[x-2][y+2]=='.')&&(t==0))
                    {
                        r=rand()/16335+1;
                        if(r==1)
                        {
                            map[x+1][y-1]=ch2;
                        }
                        else
                        {
                            map[x-2][y+2]=ch2;
                        }
                        t=1;
                    }
                }
            }

            for(x=1; x<20; x++) // <電腦優先順序14> 將被玩家擋一邊的二子連成三子(進攻)
            {
                for(y=1; y<20; y++)
                {
                    //如果有被擋左方橫的二顆子,則右方補上一顆連成三子!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==ch2)&&(map[x-1][y]==ch1)&&(map[x+2][y]=='.')&&(t==0))
                    {
                        map[x+2][y]=ch2;
                        t=1;
                    }
                    //如果有被擋右方直的二顆子,則左方補上一顆連成三子!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==ch2)&&(map[x+2][y]==ch1)&&(map[x-1][y]=='.')&&(t==0))
                    {
                        map[x-1][y]=ch2;
                        t=1;
                    }
                    //如果有被擋上方橫的二顆子,則下方補上一顆連成三子!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==ch2)&&(map[x][y-1]==ch1)&&(map[x][y+2]=='.')&&(t==0))
                    {
                        map[x][y+2]=ch2;
                        t=1;
                    }
                    //如果有被擋下方橫的二顆子,則上方補上一顆連成三子!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==ch2)&&(map[x][y+2]==ch1)&&(map[x][y-1]=='.')&&(t==0))
                    {
                        map[x][y-1]=ch2;
                        t=1;
                    }
                    //如果有被擋左上方左斜的二顆子,則右下方補上一顆連成三子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==ch2)&&(map[x-1][y-1]==ch1)&&(map[x+2][y+2]=='.')&&(t==0))
                    {
                        map[x+2][y+2]=ch2;
                        t=1;
                    }
                    //如果有被擋右下方左斜的二顆子,則左上方補上一顆連成三子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==ch2)&&(map[x+2][y+2]==ch1)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如果有被擋右上方右斜的二顆子,則左下方補上一顆連成三子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==ch2)&&(map[x+1][y-1]==ch1)&&(map[x-2][y+2]=='.')&&(t==0))
                    {
                        map[x-2][y+2]=ch2;
                        t=1;
                    }
                    //如果有被擋左下方右斜的二顆子,則右上方補上一顆連成三子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==ch2)&&(map[x-2][y+2]==ch1)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序15> 當電腦有靠邊界的二子時,補上成三子(進攻)
            {
                for(y=1; y<21; y++)
                {
                    //如電腦已有靠左邊界的二子橫連線,則在右方補上子!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==ch2)&&(x==1)&&(map[x+2][y]=='.')&&(t==0))
                    {
                        map[x+2][y]=ch2;
                        t=1;
                    }
                    //如電腦已有靠右邊界的二子橫連線,則在左方補上子!
                    if((map[x][y]==map[x+1][y])&&(map[x][y]==ch2)&&(x==17)&&(map[x-1][y]=='.')&&(t==0))
                    {
                        map[x-1][y]=ch2;
                        t=1;
                    }
                    //如電腦已有靠上邊界的二子直連線,則在下方補上子!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==ch2)&&(y==1)&&(map[x][y+2]=='.')&&(t==0))
                    {
                        map[x][y+2]=ch2;
                        t=1;
                    }
                    //如電腦已有靠下邊界的二子直連線,則在上方補上子!
                    if((map[x][y]==map[x][y+1])&&(map[x][y]==ch2)&&(y==17)&&(map[x][y-1]=='.')&&(t==0))
                    {
                        map[x][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠上邊界的二子左斜連線,則在右下方補上子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==ch2)&&(y==1)&&(map[x+2][y+2]=='.')&&(t==0))
                    {
                        map[x+2][y+2]=ch2;
                        t=1;
                    }
                    //如電腦已有靠下邊界的二子左斜連線,則在左上方補上子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==ch2)&&(y==17)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠左邊界的二子左斜連線,則在右下方補上子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==ch2)&&(x==1)&&(map[x+2][y+2]=='.')&&(t==0))
                    {
                        map[x+2][y+2]=ch2;
                        t=1;
                    }
                    //如電腦已有靠右邊界的二子左斜連線,則在左上方補上子!
                    if((map[x][y]==map[x+1][y+1])&&(map[x][y]==ch2)&&(x==17)&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        map[x-1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠上邊界的二子右斜連線,則在左下方補上子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==ch2)&&(y==1)&&(map[x-2][y+2]=='.')&&(t==0))
                    {
                        map[x-2][y+2]=ch2;
                        t=1;
                    }
                    //如電腦已有靠下邊界的二子右斜連線,則在右上方補上子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==ch2)&&(y==17)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠左邊界的二子右斜連線,則在右上方補上子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==ch2)&&(x==1)&&(map[x+1][y-1]=='.')&&(t==0))
                    {
                        map[x+1][y-1]=ch2;
                        t=1;
                    }
                    //如電腦已有靠右邊界的二子右斜連線,則在左下方補上子!
                    if((map[x][y]==map[x-1][y+1])&&(map[x][y]==ch2)&&(x==17)&&(map[x-2][y+2]=='.')&&(t==0))
                    {
                        map[x-2][y+2]=ch2;
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序16> 當電腦有單顆子時,補上子成活二(進攻)
            {
                for(y=1; y<21; y++)
                {
                    if((map[x][y]==ch2)&&(map[x+1][y]=='.')&&(map[x-1][y]=='.')&&(map[x][y+1]=='.')&&(map[x][y-1]=='.')
                            &&(map[x+1][y+1]=='.')&&(map[x+1][y-1]=='.')&&(map[x-1][y+1]=='.')&&(map[x-1][y-1]=='.')&&(t==0))
                    {
                        r=rand()/4084+1;
                        if(r==1)
                        {
                            map[x+1][y]=ch2;
                        }
                        else if(r==2)
                        {
                            map[x-1][y]=ch2;
                        }
                        else if(r==3)
                        {
                            map[x][y+1]=ch2;
                        }
                        else if(r==4)
                        {
                            map[x][y-1]=ch2;
                        }
                        else if(r==5)
                        {
                            map[x+1][y+1]=ch2;
                        }
                        else if(r==6)
                        {
                            map[x+1][y-1]=ch2;
                        }
                        else if(r==7)
                        {
                            map[x-1][y+1]=ch2;
                        }
                        else
                        {
                            map[x-1][y-1]=ch2;
                        }
                        t=1;
                    }
                }
            }

            for(x=1; x<21; x++) // <電腦優先順序17> 當電腦有被擋的顆子時,在沒被擋的地方補上子成活二(進攻)
            {
                for(y=1; y<21; y++)
                {
                    //巢狀式由左上=>右下的八個點依序判定電腦的子是否被阻擋,是的話換其它點,否的話加上子於該點!
                    if((map[x][y]==ch2)&&(t==0))
                    {
                        if(map[x-1][y-1]==ch1)
                        {
                            if(map[x][y-1]==ch1)
                            {
                                if(map[x+1][y-1]==ch1)
                                {
                                    if(map[x-1][y]==ch1)
                                    {
                                        if(map[x+1][y]==ch1)
                                        {
                                            if(map[x-1][y+1]==ch1)
                                            {
                                                if(map[x][y+1]==ch1)
                                                {
                                                    if(map[x+1][y+1]==ch1)
                                                    {
                                                        t=-1;
                                                    }
                                                    else
                                                    {
                                                        map[x+1][y+1]=ch2;
                                                    }
                                                }
                                                else
                                                {
                                                    map[x][y+1]=ch2;
                                                }
                                            }
                                            else
                                            {
                                                map[x-1][y+1]=ch2;
                                            }
                                        }
                                        else
                                        {
                                            map[x+1][y]=ch2;
                                        }
                                    }
                                    else
                                    {
                                        map[x-1][y]=ch2;
                                    }
                                }
                                else
                                {
                                    map[x+1][y-1]=ch2;
                                }
                            }
                            else
                            {
                                map[x][y-1]=ch2;
                            }
                        }
                        else
                        {
                            map[x-1][y-1]=ch2;
                        }
                        t++;
                    }
                }
            }

            // <電腦優先順序18> 當電腦所有子都被擋,重新找點下子!(進攻)

            if(t==0)
            {
                for(i=0; i<1;)
                {
                    x=rand()/1634+1;
                    y=rand()/1634+1;
                    if((map[x][y]=='.')&&(map[x-1][y-1]=='.')&&(map[x][y-1]=='.')&&(map[x+1][y-1]=='.')&&(map[x-1][y]=='.')
                            &&(map[x+1][y]=='.')&&(map[x-1][y+1]=='.')&&(map[x][y+1]=='.')&&(map[x+1][y+1]=='.')&&(t==0))
                    {
                        map[x][y]=ch2;
                        t=1;
                        i++;
                    }
                }
            }
            n2++;
        }

        system("cls");
        cout<<"   ";
        for(i=1; i<10; i++)
        {
            cout<<i<<" ";
        }
        for(i=10; i<21; i++)
        {
            cout<<i;
        }
        cout<<endl;

        for(x=1; x<21; x++)
        {
            printf("%2d ",x);
            for(y=1; y<21; y++)
            {
                cout<<map[x][y]<<" ";
            }
            cout<<endl;
        }
        printf("******************************************\n");
        printf("*       %c玩家A:%3d     %c電腦:%3d         *\n",ch1,n1,ch2,n2);
        printf("******************************************\n");

        for(x=1; x<21; x++)
        {
            for(y=1; y<21; y++)
            {
                //直的連線判斷式
                if((map[x][y]==map[x+1][y])&&(map[x][y]==map[x+2][y])&&(map[x][y]==map[x+3][y])
                        &&(map[x][y]==map[x+4][y])&&(map[x][y]!='.'))
                {
                    map[x][y]=15,map[x+1][y]=15,map[x+2][y]=15,map[x+3][y]=15,map[x+4][y]=15;
                    q--;
                }
                //橫的連線判斷式
                if((map[x][y]==map[x][y+1])&&(map[x][y]==map[x][y+2])&&(map[x][y]==map[x][y+3])
                        &&(map[x][y]==map[x][y+4])&&(map[x][y]!='.'))
                {
                    map[x][y]=15,map[x][y+1]=15,map[x][y+2]=15,map[x][y+3]=15,map[x][y+4]=15;
                    q--;
                }
                //左斜的連線判斷式
                if((map[x][y]==map[x+1][y+1])&&(map[x][y]==map[x+2][y+2])&&(map[x][y]==map[x+3][y+3])
                        &&(map[x][y]==map[x+4][y+4])&&(map[x][y]!='.'))
                {
                    map[x][y]=15,map[x+1][y+1]=15,map[x+2][y+2]=15,map[x+3][y+3]=15,map[x+4][y+4]=15;
                    q--;
                }
                //右斜的連線判斷式
                if((map[x][y]==map[x-1][y+1])&&(map[x][y]==map[x-2][y+2])&&(map[x][y]==map[x-3][y+3])
                        &&(map[x][y]==map[x-4][y+4])&&(map[x][y]!='.'))
                {
                    map[x][y]=15,map[x-1][y+1]=15,map[x-2][y+2]=15,map[x-3][y+3]=15,map[x-4][y+4]=15;
                    q--;
                }
            }
        }

        if(q==0)
        {
            system("cls");
            cout<<"   ";
            for(i=1; i<10; i++)
            {
                cout<<i<<" ";
            }
            for(i=10; i<21; i++)
            {
                cout<<i;
            }
            cout<<endl;

            for(x=1; x<21; x++)
            {
                printf("%2d ",x);
                for(y=1; y<21; y++)
                {
                    cout<<map[x][y]<<" ";
                }
                cout<<endl;
            }
            printf("******************************************\n");
            printf("*       %c玩家A:%3d     %c電腦:%3d         *\n",ch1,n1,ch2,n2);
            printf("******************************************\n");
            if(count%2==0)
            {
                printf("*              恭喜您勝利!               *\a\n");
            }
            else
            {
                printf("*               電腦勝利!                *\a\n");
            }
            printf("******************************************\n");
        }
    }

    getch();
}
